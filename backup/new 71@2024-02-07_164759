@AllArgsConstructor
@NoArgsConstructor
@Data
@Builder
@Entity(name = "Order_Item")
@NamedEntityGraph(
        name = "orderItem-entity-graph",
        attributeNodes = {
//                @NamedAttributeNode("id"), // no necessary as in many cases, the IDs are automatically fetched along with the entities when they are loaded from the database, so explicitly including them in the entity graph might not be necessary.
                @NamedAttributeNode("productName"),
                @NamedAttributeNode("price"),
                @NamedAttributeNode("quantity"),
              @NamedAttributeNode(value = "order", subgraph = "orderSubgraph")
        },
        subgraphs = {
                @NamedSubgraph(
                        name = "orderSubgraph",
                        attributeNodes = {
//                                @NamedAttributeNode("id"), // no necessary as in many cases, the IDs are automatically fetched along with the entities when they are loaded from the database, so explicitly including them in the entity graph might not be necessary.
                                @NamedAttributeNode("orderNumber"),
                                @NamedAttributeNode("orderDate"),
                              @NamedAttributeNode("orderItems")
                        }
                )
        }
)
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String productName;
    private Double price;

    @Basic(fetch = FetchType.LAZY)
    private Integer quantity;

    /**
     * The reason for puttign @JsonIgnore : If you remove this annotation, then while saving the Order,
     * When you serialize an Order object, it tries to serialize its associated OrderItem objects, which in turn reference the parent Order object, leading to a cyclic reference.
     * As as result we will get, equest processing failed: org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: Infinite recursion (StackOverflowError)] with root cause
     * java.lang.StackOverflowError: null
     */
    @ManyToOne
//    @ManyToOne(fetch = FetchType.LAZY) // Default behaviour is eager for ManyToOne if you override fetch type to lazy, you will see two queries, else only one query in the console after enabling hibernate logs.
//    @JoinColumn(name = "order_id") // This is the name of order column inside Order_Item table. We need to set each order explicitly on orderItems field of order entity
    @JsonIgnore
    private Order order;
}


@AllArgsConstructor
@NoArgsConstructor
@Data
@Builder
@Entity(name = "CustomerOrder")
@NamedEntityGraph(
        name = "order-entity-graph-with-orderItems",
        attributeNodes = {
                @NamedAttributeNode("orderNumber"),
                @NamedAttributeNode("orderDate"),
                @NamedAttributeNode(value = "orderItems", subgraph = "orderItemsSubgraph"),
        },
        subgraphs = {
                @NamedSubgraph(
                        name = "orderItemsSubgraph",
                        attributeNodes = {
                                @NamedAttributeNode("productName"),
                                @NamedAttributeNode("price"),
                                @NamedAttributeNode("quantity"),
                                @NamedAttributeNode("order")
                        }
                )
        }
)
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String orderNumber;
    private Date orderDate;

    //TODO do one poc in the same project using set collection instead of List
//    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
//    private Set<OrderItem> orderItems = new HashSet<>();

    //mappedBy = "order", order is the field name of Order object inside OrderItem
    @OneToMany(
            mappedBy = "order", // This is the name of the Order type variable inside orderItem entity, since this is a bidirectional relationship
            fetch = FetchType.EAGER,
            // cascade = CascadeType.ALL: If we perform any ooperation on order entity, that operation will also be cascaded to order item entity
            //such as PERSIST, MERGE, REMOVE, DETACH, REFRESH, ALL (This includes all of the above cascade options.)
            cascade = CascadeType.ALL,
            orphanRemoval = true // If order is deleted, all orderItem wil also be removed
    )
    private List<OrderItem> orderItems = new ArrayList<>();

    public void addOrderItem(OrderItem orderItem) {
        orderItems.add(orderItem);
        orderItem.setOrder(this);
    }

    public void removeOrderItem(OrderItem orderItem) {
        orderItems.remove(orderItem);
        orderItem.setOrder(null);
    }

}

@Repository
public interface OrderItemRepository extends JpaRepository<OrderItem, Long> {

//    @EntityGraph(value = "Order.orderItems", type = EntityGraph.EntityGraphType.LOAD)
    @EntityGraph(value = "order-entity-graph-with-orderItems", type = EntityGraph.EntityGraphType.LOAD)
    List<OrderItem> findByOrderId(Long orderId);

//    @EntityGraph(value = "Order.orderItems", type = EntityGraph.EntityGraphType.FETCH)
    Optional<OrderItem> findByIdAndOrderId(Long orderItemId, Long orderId);
}

I have two entities classes Order and OrderItem as given above. When I am calling findByOrderId in OrderItemRepository class, 
both Order and OrderItem entities are being loaded eagerly, even though I have mentioned below @EntityGraph annotation over findByOrderId method.
@EntityGraph(value = "order-entity-graph-with-orderItems", type = EntityGraph.EntityGraphType.LOAD)

My target is to load OrderId entity lazily through entity graph (which is annotated with @ManyToOne annoation inside OrderItem enity) when I will call findByOrderId from 
OrderItemRepository. Could you please modify the above code.

@Entity@Table(name = "customer")@NamedEntityGraph(name = "graph.Customer.name", attributeNodes = @NamedAttributeNode("name"))public class Customer {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    private String name;    // getters and setters omitted for brevity}

select 
oi1_0.id,
oi1_0.order_id,
oi1_0.price,
oi1_0.product_name,
oi1_0.quantity 

from order_item oi1_0 left join customer_order o1_0 on o1_0.id=oi1_0.order_id where o1_0.id=?

select 
oi1_0.id,
oi1_0.order_id,
oi1_0.price,
oi1_0.product_name,
oi1_0.quantity 

from order_item oi1_0 left join customer_order o1_0 on o1_0.id=oi1_0.order_id where o1_0.id=?

can you give me a jpql query to fetch only productName and price from this entity.
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String productName;
    private Double price;

    @Basic(fetch = FetchType.LAZY)
    private Integer quantity;

    /**
     * The reason for puttign @JsonIgnore : If you remove this annotation, then while saving the Order,
     * When you serialize an Order object, it tries to serialize its associated OrderItem objects, which in turn reference the parent Order object, leading to a cyclic reference.
     * As as result we will get, equest processing failed: org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: Infinite recursion (StackOverflowError)] with root cause
     * java.lang.StackOverflowError: null
     */
    @ManyToOne
//    @ManyToOne(fetch = FetchType.LAZY) // Default behaviour is eager for ManyToOne if you override fetch type to lazy, you will see two queries, else only one query in the console after enabling hibernate logs.
//    @JoinColumn(name = "order_id") // This is the name of order column inside Order_Item table. We need to set each order explicitly on orderItems field of order entity
    @JsonIgnore
    private Order order;
}




@Query("SELECT oi.productName, oi.price FROM Order_Item oi")
    List<OrderItem> findAllOrderItems();
		
		Certainly! Here are some official resources where you can learn more about Entity Graphs in JPA:

1. **Java Persistence API (JPA) Specification**: The official specification for JPA provides detailed information about Entity Graphs. You can find the specification on the Java Community Process (JCP) website:
   [Java Persistence API (JPA) Specification](https://jcp.org/en/jsr/detail?id=338)

2. **Spring Data JPA Documentation**: If you're using Spring Data JPA, their documentation covers the usage of Entity Graphs. You can refer to the official documentation for more information:
   [Spring Data JPA Documentation](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.entity-graph)

3. **Hibernate User Guide**: Since Hibernate is one of the most popular JPA implementations, their documentation also provides insights into using Entity Graphs. You can find relevant information in the Hibernate User Guide:
   [Hibernate User Guide](https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#entity-graph)

These resources should provide you with comprehensive information about Entity Graphs in JPA.