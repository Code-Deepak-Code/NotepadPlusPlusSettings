 I have this method inside OrderRepository. But it is fetching all the 
 @EntityGraph(attributePaths = {"orderNumber", "orderItems.quantity"})
    List<Order> findAll();

This is the hibernate query from debug log.
select o1_0.id,o1_0.order_date,oi1_0.order_id,oi1_0.id,oi1_0.price,oi1_0.product_name,oi1_0.quantity,o1_0.order_number from customer_order o1_0 left join order_item oi1_0 on o1_0.id=oi1_0.order_id

select o1_0.id,o1_0.order_date,oi1_0.order_id,oi1_0.id,oi1_0.price,oi1_0.product_name,oi1_0.quantity,o1_0.order_number from customer_order o1_0 left join order_item oi1_0 on o1_0.id=oi1_0.order_id

select o1_0.id,o1_0.order_date,oi1_0.order_id,oi1_0.id,oi1_0.price,oi1_0.product_name,oi1_0.quantity,o1_0.order_number from customer_order o1_0 left join order_item oi1_0 on o1_0.id=oi1_0.order_id

select o1_0.id,o1_0.order_date,oi1_0.order_id,oi1_0.id,oi1_0.price,oi1_0.product_name,oi1_0.quantity,o1_0.order_number from customer_order o1_0 left join order_item oi1_0 on o1_0.id=oi1_0.order_id
select 

select o1_0.id,o1_0.order_date,oi1_0.order_id,oi1_0.id,oi1_0.price,oi1_0.product_name,oi1_0.quantity,o1_0.order_number from customer_order o1_0 left join order_item oi1_0 on o1_0.id=oi1_0.order_id

select o1_0.id,o1_0.order_date,oi1_0.order_id,oi1_0.id,oi1_0.price,oi1_0.product_name,oi1_0.quantity,o1_0.order_number from customer_order o1_0 left join order_item oi1_0 on o1_0.id=oi1_0.order_id

select o1_0.id,o1_0.order_date,o1_0.order_number,oi1_0.order_id,oi1_0.id,oi1_0.price,oi1_0.product_name,oi1_0.quantity from customer_order o1_0 left join order_item oi1_0 on o1_0.id=oi1_0.order_id where o1_0.id=?

o1_0.id,
o1_0.order_date,

oi1_0.order_id,
oi1_0.id,
oi1_0.price,
oi1_0.product_name,
oi1_0.quantity,

o1_0.order_number

 from customer_order o1_0 
 left join order_item oi1_0 on o1_0.id=oi1_0.order_id
 
 what is the difference between
 type = EntityGraph.EntityGraphType.FETCH and 
 type = EntityGraph.EntityGraphType.LOAD
 
 Can you give me the jpa method to fetch only orderNumber from Order entity and quantity from orderItems entity.
 
 I have these this method with entitygraph annoation, shoudl it fetch orderNumber and quantity eagerly since type = EntityGraph.EntityGraphType.FETCH
 
  @EntityGraph(attributePaths = {"orderNumber", "orderItems.quantity"}, type = EntityGraph.EntityGraphType.FETCH)
    @Query("SELECT o.orderNumber, oi.quantity FROM CustomerOrder o JOIN o.orderItems oi")
    List<Object[]> findOrderNumberAndQuantity();
		
Yes, you can lazily load elements of the main entity in JPA.

In JPA, you can configure lazy loading for associations or attributes of an 
entity using the fetch attribute in the mapping annotations (@OneToMany, @ManyToOne, etc.) or 
through fetch plans such as @EntityGraph.

For example, let's say you have an entity Order with a one-to-many association to OrderItem. 
You can configure lazy loading for the OrderItem collection in the Order entity like this:

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
	
		 @EntityGraph(attributePaths = {"orderNumber", "orderItems.quantity"}, type = EntityGraph.EntityGraphType.FETCH)
    @EntityGraph(attributePaths = "orderItems")
    List<Order> findAll();

  
}

If I have this method in jparepository, what will be the hibernate logs generated for this method.

@AllArgsConstructor
@NoArgsConstructor
@Data
@Builder
@Entity(name = "CustomerOrder")
@NamedEntityGraph(
        name = "order-entity-graph-with-orderItems",
        attributeNodes = {
                @NamedAttributeNode("orderNumber"),
                @NamedAttributeNode("orderDate"),
                @NamedAttributeNode(value = "orderItems", subgraph = "orderItemsSubgraph"),
        },
        subgraphs = {
                @NamedSubgraph(
                        name = "orderItemsSubgraph",
                        attributeNodes = {
                                @NamedAttributeNode("productName"),
                                @NamedAttributeNode("price"),
                                @NamedAttributeNode("quantity"),
                                @NamedAttributeNode("order")
                        }
                )
        }
)
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String orderNumber;
    private Date orderDate;

    //TODO do one poc in the same project using set collection instead of List
//    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
//    private Set<OrderItem> orderItems = new HashSet<>();

    //mappedBy = "order", order is the field name of Order object inside OrderItem
    @OneToMany(
            mappedBy = "order", // This is the name of the Order type variable inside orderItem entity, since this is a bidirectional relationship

            // cascade = CascadeType.ALL: If we perform any ooperation on order entity, that operation will also be cascaded to order item entity
            //such as PERSIST, MERGE, REMOVE, DETACH, REFRESH, ALL (This includes all of the above cascade options.)
            cascade = CascadeType.ALL,
            orphanRemoval = true // If order is deleted, all orderItem wil also be removed
    )
    private List<OrderItem> orderItems = new ArrayList<>();

    public void addOrderItem(OrderItem orderItem) {
        orderItems.add(orderItem);
        orderItem.setOrder(this);
    }

    public void removeOrderItem(OrderItem orderItem) {
        orderItems.remove(orderItem);
        orderItem.setOrder(null);
    }

}

@AllArgsConstructor
@NoArgsConstructor
@Data
@Builder
@Entity (name = "Order_Item")
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String productName;
    private Double price;

    @Basic(fetch = FetchType.LAZY)
    private Integer quantity;

    /**
     * The reason for puttign @JsonIgnore : If you remove this annotation, then while saving the Order,
     * When you serialize an Order object, it tries to serialize its associated OrderItem objects, which in turn reference the parent Order object, leading to a cyclic reference.
     * As as result we will get, equest processing failed: org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: Infinite recursion (StackOverflowError)] with root cause
     * java.lang.StackOverflowError: null
     */
    @ManyToOne
    @JoinColumn(name = "order_id") // This is the name of order column inside Order_Item table. We need to set each order explicitly on orderItems field of order entity
    @JsonIgnore
    private Order order;
}

These are my entities. could you please modify the hibernate logs as per the given repository method earlier.

What if I change the type = EntityGraph.EntityGraphType.LOAD. now could you please modify the hibernate logs
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
	
	@EntityGraph(attributePaths = {"orderNumber", "orderItems.quantity"}, type = EntityGraph.EntityGraphType.LOAD)
	@EntityGraph(attributePaths = "orderItems")
	List<Order> findAll();
}

