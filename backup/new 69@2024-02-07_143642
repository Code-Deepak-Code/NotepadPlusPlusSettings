@AllArgsConstructor
@NoArgsConstructor
@Data
@Builder
@Entity(name = "CustomerOrder")
@NamedEntityGraph(
        name = "order-entity-graph-with-orderItems",
        attributeNodes = {
                @NamedAttributeNode("orderNumber"),
                @NamedAttributeNode("orderDate"),
                @NamedAttributeNode(value = "orderItems", subgraph = "orderItemsSubgraph"),
        },
        subgraphs = {
                @NamedSubgraph(
                        name = "orderItemsSubgraph",
                        attributeNodes = {
                                @NamedAttributeNode("productName"),
                                @NamedAttributeNode("price"),
                                @NamedAttributeNode("quantity"),
                                @NamedAttributeNode("order")
                        }
                )
        }
)
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String orderNumber;
    private Date orderDate;

    //TODO do one poc in the same project using set collection instead of List
//    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
//    private Set<OrderItem> orderItems = new HashSet<>();

    //mappedBy = "order", order is the field name of Order object inside OrderItem
    @OneToMany(
            mappedBy = "order", // This is the name of the Order type variable inside orderItem entity, since this is a bidirectional relationship

            // cascade = CascadeType.ALL: If we perform any ooperation on order entity, that operation will also be cascaded to order item entity
            //such as PERSIST, MERGE, REMOVE, DETACH, REFRESH, ALL (This includes all of the above cascade options.)
            cascade = CascadeType.ALL,
            orphanRemoval = true // If order is deleted, all orderItem wil also be removed
    )
    private List<OrderItem> orderItems = new ArrayList<>();

    public void addOrderItem(OrderItem orderItem) {
        orderItems.add(orderItem);
        orderItem.setOrder(this);
    }

    public void removeOrderItem(OrderItem orderItem) {
        orderItems.remove(orderItem);
        orderItem.setOrder(null);
    }

}

@AllArgsConstructor
@NoArgsConstructor
@Data
@Builder
@Entity (name = "Order_Item")
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String productName;
    private Double price;

    @Basic(fetch = FetchType.LAZY)
    private Integer quantity;

    /**
     * The reason for puttign @JsonIgnore : If you remove this annotation, then while saving the Order,
     * When you serialize an Order object, it tries to serialize its associated OrderItem objects, which in turn reference the parent Order object, leading to a cyclic reference.
     * As as result we will get, equest processing failed: org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: Infinite recursion (StackOverflowError)] with root cause
     * java.lang.StackOverflowError: null
     */
    @ManyToOne
    @JoinColumn(name = "order_id") // This is the name of order column inside Order_Item table. We need to set each order explicitly on orderItems field of order entity
    @JsonIgnore
    private Order order;
}


@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    /**
     * findAllWithOrderItems() method defines a custom query method that fetches all Order entities along with their associated OrderItem entities eagerly (at the time of application startup).
     * The @EntityGraph annotation is used to specify the attribute paths to be eagerly fetched, in this case, it's just orderItems.
     */
//    @EntityGraph(attributePaths = {"orderItems"})
//    List<Order> findAllWithOrderItems();
   // List<Order> findAll();

    /**
     * Case: Only fetch attributes orderNumber from Order entity and quantity from OrderItem entity eagerly.
     * Rest other attributes insde Order and OrderItem entities shoudl be fetched lazily.
     * @EntityGraph is used with attributePaths to specify the attributes to be eagerly fetched. We specify "orderNumber" to fetch the orderNumber attribute of the Order entity eagerly, and "orderItems.quantity" to fetch the quantity attribute of the OrderItem entities eagerly.
     *
     * The rest of the attributes inside both Order and OrderItem entities will be fetched lazily by default.
     *
     */
    @EntityGraph(attributePaths = {"orderNumber", "orderItems.quantity"}, type = EntityGraph.EntityGraphType.LOAD)
//    List<Order> findAllWithOrderItemsQuantity();
    List<Order> findAll();

    @EntityGraph(attributePaths = {"orderNumber", "orderItems.quantity"}, type = EntityGraph.EntityGraphType.FETCH)
    Order findByOrderNumber(String orderNumber);

    // please note that the @EntityGraph annotation is typically used to define a graph of attributes to be eagerly fetched when loading entities via JPA repository methods, rather than in native queries like the one you're using with @Query.
//    @EntityGraph(attributePaths = {"orderNumber", "orderItems.quantity"}, type = EntityGraph.EntityGraphType.FETCH)
    @Query("SELECT o.orderNumber, oi.quantity FROM CustomerOrder o JOIN o.orderItems oi")
    List<Object[]> findOrderNumberAndQuantity();

    /**
     * findByIdWithOrderItems(Long id) method defines another custom query method that fetches a single Order entity by its ID along with its associated OrderItem entities. Similarly, the @EntityGraph annotation ensures that the orderItems collection is eagerly loaded.
     */
    @EntityGraph(attributePaths = {"orderItems"})
//    Order findByIdWithOrderItems(Long id);
    Optional<Order> findById(Long id);
    /**
     * case: only quantitiy inside orderItem entity will be fetched eagerly, along with all the elements of order entity:
     *
     * findAllWithOrderItemsQuantity() defines a custom query method to fetch all Order entities along with their associated OrderItem entities.
     * The @EntityGraph annotation is used to specify the attribute paths to be eagerly fetched. Here, we specify "orderItems.quantity" to fetch the quantity attribute of the OrderItem entities eagerly while the rest of the attributes are fetched lazily by default.
     *
     */
//    @EntityGraph(attributePaths = {"orderItems.quantity"})
//    List<Order> findAllWithOrderItemsQuantity();


}

I have specified both the Order and OrderItem entity as well as the repositoy. Could you please check why I am seeing only one log.


spring:
  datasource:
    driver-class-name: org.h2.Driver
    password: password
    url: jdbc:h2:mem:dev
    username: sa
  jpa:
    show-sql: true

logging:
  level:
    org.hibernate.sql: DEBUG
		
this is my application.yml file. is it correct to show two hiberate logs as per lazy load

Hibernate: select oi1_0.id,oi1_0.order_id,oi1_0.price,oi1_0.product_name,oi1_0.quantity from order_item oi1_0 left join customer_order o1_0 on o1_0.id=oi1_0.order_id where o1_0.id=?

Hibernate: select o1_0.id,o1_0.order_date,o1_0.order_number,oi1_0.order_id,oi1_0.id,oi1_0.price,oi1_0.product_name,oi1_0.quantity from customer_order o1_0 left join order_item oi1_0 on o1_0.id=oi1_0.order_id where o1_0.id=?

Hibernate: select 
oi1_0.id,
oi1_0.order_id,
oi1_0.price,
oi1_0.product_name,
oi1_0.quantity 
from order_item oi1_0 left join customer_order o1_0 on o1_0.id=oi1_0.order_id where o1_0.id=?

Hibernate: 
select 
o1_0.id,
o1_0.order_date,
o1_0.order_number,

oi1_0.order_id,
oi1_0.id,oi1_0.price,
oi1_0.product_name,

oi1_0.quantity from customer_order o1_0 left join order_item oi1_0 on o1_0.id=oi1_0.order_id where o1_0.id=?
